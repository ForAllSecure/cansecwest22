# Connman DHCP Client Lab

For this lab, I have already created a harness for the Connman DHCP Client. However, it gets stuck, so I'm unable to find an input that reaches the vulnerability used by the TBONE exploit. In this lab, we'll look at fuzzing coverage and how to improve it.

## Step 1. Build the Connman DHCP Client Harness Locally

First change into the connman source directory included in the CanSecWest repo (adjust the path as neccesary):

```
cd cansecwest22/connman/connman
```

Run the `bootstrap` script:

```
./bootstrap
```

Run the `configure` script, enabling debugging:

```
./configure --enable-debug
```

Next, run make:

```
make
```

Change directories to `cansecwest22/connman`:

```
cd ../
```

For this lab, I have already created a Dockerfile to package up the DHCP client harness. You can build it using this command:

```
docker build -t ghcr.io/<YOUR GITHUB USERNAME>/connman-dhcp-client:latest .
```

Now, push the DHCP client image up to the GitHub container registry:

```
docker push ghcr.io/<YOUR GITHUB USERNAME>/connman-dhcp-client:latest
```

Finally, mark the image as public using [these instructions](https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility#configuring-visibility-of-container-images-for-your-personal-account).

## Step 2. Fuzz the DHCP Client with Mayhem and Coverage Collection

Let's start fuzzing the DHCP client. First, we need to create a `Mayhemfile`:

```
mayhem init ghcr.io/<YOUR GITHUB USERNAME>/connman-dhcp-client:latest
```

The resulting `Mayhemfile` is almost complete, but we need to adjust a few things. Using your favorite text editor, you need to set the input path using `@@`, set a duration for fuzzing, enable advanced triage, and finally you'll need to enable coverage analysis.

Your resulting `Mayhemfile should in effect, look something like this:

```
project: connman-dhcp-client
target: connman-dhcp-client-latest

image: ghcr.io/nathanjackson/connman-dhcp-client:latest

tasks:
  - name: regression_testing
  - name: behavior_testing
  - name: coverage_analysis

advanced_triage: true

duration: 300

cmds:
  - cmd: /fuzz_dhcp_client @@
```

Finally, let's start a run:

```
mayhem run .
```

We configured our Mayhemfile to run for five minutes. We can see pretty early on that we do find an uninitialized memory read, but drilling down into the issue, we see that it is indeed pointing to the same variable as in the TBONE exploit as uninitialized. However, this particular use of uninitialized memory isn't the problem. So we need to figure out why our driver didn't execute the problematic code.

## Step 3. Identify Failing Check with lcov

One way of evaluating a run is to look at its coverage. In this step, we'll download the coverage data generated by Mayhem and use lcov to view the results.

First, download the artifacts generated by Mayhem using `mayhem sync`:

```
mayhem sync .
```

Next, let's generate the `lcov` HTML report. Because of the way `lcov` works, we need to be in the source directory:

```
cd connman/
genhtml -o /tmp/html --ignore-errors source ../line_coverage.lcov
cd -
```

Open `/tmp/html/index.html` with your web browser, and navigate to the `gdhcp/client.c` file. If we look at the coverage data for the `listener_event` function, we can see that it seems to get stuck in `check_package_owner`.  Let's work backwards to see why.

There is one check that we are failing. The packet `xid` needs to requal `dhcp_client->xid`. So how did `dhcp_client->xid` get set? It turns out that the `dhcp_client->xid` gets set from a call to `dhcp_get_random`. We've found some non-determinism in our target!

Looking at the `dhcp_get_random` function, we can see that it pulls from `/dev/urandom`.

## Step 4. Override the Open System Call

One trick to get around the non-determinism caused by reading from `/dev/urandom` is to fake out opening a different file that isn't random. There isn't anything really special about `/dev/urandom`, other than it generates random data. So instead, we could open `/dev/zero` which will always return zeroes.

There are multiple ways to do this, we could simply patch the `dhcp_get_random` function, but then we have to change the DHCP code.

Another way to do this is to intercept the open system call and return a file descriptor to `/dev/zero`. While this is more complicated than patching, it also has the advantage that we can keep our fuzzing specific code contained: `fuzz_dhcp_client.c`.

So using your favorite text editor, modify `connman/mayhem/fuzz_dhcp_client.c` by adding an `open` function like so:

```
...
int open(const char *pathname, int flags, ...)
{
    static int (*real_open)(const char*, int, ...) = NULL;

    if (NULL == real_open) {
        real_open = dlsym(RTLD_NEXT, "open");
    }
    assert(real_open);

    if (0 == strcmp(pathname, "/dev/urandom")) {
        return real_open("/dev/zero", O_RDONLY);
    }

    return real_open(pathname, flags);
}
...
```

How does this work? Well, when you call a system call like `open` in C, you're not actually invoking the system call directly. Instead, you're calling glibc's wrapper function that invokes the system call for you. By providing our own open function, the linker won't attempt to bind the open symbol to the wrapper in GLIBC, thus executing our code instead.

However, we don't want to completely break open. We just want to prevent our test driver from opening `/dev/urandom`. So we'll use the runtime linker to find the real `open` symbol and call it as-is so long as the file isn't `/dev/urandom`.

Once you've modified the code, rebuild and push your Docker image:

```
cd connman/
make
cd -
docker build -t ghcr.io/<YOUR GITHUB USERNAME>/connman-dhcp-client:latest -f dhcp-client/Dockerfile .
docker push ghcr.io/<YOUR GITHUB USERNAME>/connman-dhcp-client:latest
```

## Step 5. Fuzz Again, Find Defect

Finally, start a new run:

```
mayhem run .
```

You should see within a few seconds that Mayhem finds additional defects, one of which is the same issue in the TBONE write up.

